<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" name="viewport" content="width=device-width, initial-scale=0.8, user-scalable=no">
    <title>maze1</title>
</head>
<body>
    <canvas id="c2d" class="c2d" width="390" height="290"></canvas>
    <script>
        var oC2 = document.getElementById('c2d');
        var ctx = oC2.getContext('2d');

        var width = oC2.width;
        var height = oC2.height;
        var maxX = 18;
        var maxY = 13;

        var firstGrid;
        var endGrid;

        function Grid(x, y) {
            this.x = x;
            this.y = y;
            this.choosed = false;
            this.isPath = false;
            this.children = [];
            this.initNeighbor();
        }

        // 获取所有邻居
        Grid.prototype.initNeighbor = function() {
            var x = this.x;
            var y = this.y;

            this.neighbor = [];

            if(y > 0) {
                this.neighbor.push({
                   x: x,
                   y: y - 1 
                });
            }

            if(y < maxY) {
                this.neighbor.push({
                    x: x,
                    y: y + 1
                });
            }

            if(x > 0) {
                this.neighbor.push({
                   x: x - 1,
                   y: y 
                });
            }

            if(x < maxX) {
                this.neighbor.push({
                   x: x + 1,
                   y: y
                });
            }

            // 邻居数组乱序
            this.neighbor.sort(function() {
                return 0.5 - Math.random();
            });
        };

        // 获取单个邻居
        Grid.prototype.getNeighbor = function() {
            var x, y, neighbor;

            // 当前格子被选中（画路）
            this.choosed = true;

            for (var i = 0; i < this.neighbor.length; i++) {
                x = this.neighbor[i].x;
                y = this.neighbor[i].y;

                neighbor = maze.grids[y][x];

                // 邻居未被选中，则返回该邻居对应的格子
                if(!neighbor.choosed) {
                    // 标识当前格子是该邻居的父亲
                    neighbor.parent = this;

                    return neighbor;
                }
            }

            // 此时，不存在未被选中的邻居

            // 当倒退到起点时，所有岔路就被寻找完了，
            // 整个寻路过程结束；
            if (this.parent === firstGrid) {
                return 0;

            // 处理分叉；
            // 由于现在没有可以选择的邻居，
            // 所以倒回去，将指针切换回父亲，寻找新的岔路
            } else {
                return 1;
            }
        };

        function Maze() {
            this.path = [];
            this.grids = [];
            this.stack = [];
            this.init();
        }

        Maze.prototype.init = function() {
            for(var i = 0; i <= maxY; i++) {
                this.grids[i] = [];
                for(var j = 0; j <= maxX; j++) {
                    this.grids[i][j] = new Grid(j, i);
                }
            }

            firstGrid = this.grids[0][0];
            endGrid   = this.grids[13][18];
        };

        Maze.prototype.findPath = function() {
            var tmp;
            var curr = firstGrid; // (0, 0)

            while(1) {
                // 获取随机一个邻居
                tmp = curr.getNeighbor();

                if(tmp === 0) {
                    // 无邻居
                    console.log('路径找寻结束');
                    break;

                } else if(tmp === 1) {
                    // 指针切换到父亲；
                    // 为了画分叉的路，即为父亲追加新的孩子
                    curr = curr.parent;

                } else {
                    // 只有一个邻居
                    // 当前格子追加当前邻居为孩子
                    curr.children[curr.children.length] = tmp;
                    
                    // 指针切换到该邻居
                    curr = tmp;
                }
            }
        };

        function drawPath(node) {
            // 画第一格
            drawRect(node.x * 20, node.y * 20);

            for (var i = 0; i < node.children.length; i++) {
                if(node.children[i]) {
                    // 画第二格
                    drawRect(node.x * 20 + (node.children[i].x - node.x) * 10,
                             node.y * 20 + (node.children[i].y - node.y) * 10);
                    
                    setTimeout(drawPath, 0, node.children[i]);
                }
            }

        }

        function drawRect(x, y) {
            ctx.fillRect(x + 10, y + 10, 10, 10);
        }

        function drawDebug(x, y, color) {
            ctx.beginPath();
            ctx.fillStyle = color;
            ctx.arc(x, y, 1, 0, Math.PI * 2, false);
            ctx.fill();
            ctx.closePath();
        }

        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, width, height);
        ctx.fillStyle = 'white';

        var maze = new Maze();

        maze.findPath();

        drawPath(firstGrid);

        drawStartEnd();

        function drawStartEnd() {
            ctx.fillRect(0, 10, 10, 10);
            ctx.fillRect(19 * 20, 13 * 20 + 10, 10, 10);
        }
    </script>
</body>
</html>